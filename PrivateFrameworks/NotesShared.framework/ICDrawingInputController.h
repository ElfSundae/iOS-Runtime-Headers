/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/NotesShared.framework/NotesShared
 */

@interface ICDrawingInputController : NSObject <ICDrawingInputFilter> {
    BOOL _canSnapToRuler;
    ICDrawingCommand *_currentCommand;
    int _currentInputType;
    <ICDrawingInputControllerDelegate> *_delegate;
    struct vector<ICDrawingOutputPoint, std::__1::allocator<ICDrawingOutputPoint> > { 
        struct { /* ? */ } *__begin_; 
        struct { /* ? */ } *__end_; 
        struct __compressed_pair<ICDrawingOutputPoint *, std::__1::allocator<ICDrawingOutputPoint> > { 
            struct { /* ? */ } *__first_; 
        } __end_cap_; 
    } _drawOutputPoints;
    struct vector<ICDrawingInputPoint, std::__1::allocator<ICDrawingInputPoint> > { 
        struct { /* ? */ } *__begin_; 
        struct { /* ? */ } *__end_; 
        struct __compressed_pair<ICDrawingInputPoint *, std::__1::allocator<ICDrawingInputPoint> > { 
            struct { /* ? */ } *__first_; 
        } __end_cap_; 
    } _drawPoints;
    BOOL _drawingEndedButNotFinished;
    NSObject<OS_dispatch_semaphore> *_drawingWaitForFinishSemaphore;
    BOOL _ended;
    NSMutableSet *_estimatedTouchesForUpdating;
    BOOL _hasSetAngle;
    int _immutableCount;
    NSMutableDictionary *_indexToEstimatedTouchMap;
    NSObject<OS_dispatch_queue> *_inputQueue;
    float _inputScale;
    ICDrawingInputSmoother *_inputSmoother;
    BOOL _isSnappedToRuler;
    BOOL _isSnappedToRulerTopSide;
    float _lastStrokeRadius;
    float _minimumPointDistanceSq;
    BOOL _needToCheckForStartHook;
    NSObject<OS_dispatch_queue> *_outputQueue;
    struct CGAffineTransform { 
        float a; 
        float b; 
        float c; 
        float d; 
        float tx; 
        float ty; 
    } _rulerTransform;
    float _rulerWidth;
    float _smoothingKernel;
    BOOL _useRuler;
}

@property (nonatomic) BOOL canSnapToRuler;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, copy) NSString *description;
@property (readonly) unsigned int hash;
@property (nonatomic, retain) ICDrawingInputSmoother *inputSmoother;
@property BOOL isSnappedToRuler;
@property (nonatomic) BOOL isSnappedToRulerTopSide;
@property (nonatomic) BOOL needToCheckForStartHook;
@property (readonly) NSObject<ICDrawingInputFilter> *outputFilter;
@property (nonatomic) struct CGAffineTransform { float x1; float x2; float x3; float x4; float x5; float x6; } rulerTransform;
@property (nonatomic) float rulerWidth;
@property (readonly) Class superclass;
@property (nonatomic) BOOL useRuler;

+ (void)initialize;
+ (void)setupDefaults;

- (id).cxx_construct;
- (void).cxx_destruct;
- (void)_drawingAddPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1;
- (float)baseRadiusForCommandType:(unsigned int)arg1;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })baseValuesforCommandType:(unsigned int)arg1;
- (void)calculateStrokeAzimuth;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })calculateVelocityForFirstPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })calculateVelocityForNewPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1 previousPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg2;
- (BOOL)canSnapToRuler;
- (unsigned int)copyUpdatedRangeFromIndex:(unsigned int)arg1 into:(struct vector<ICDrawingOutputPoint, std::__1::allocator<ICDrawingOutputPoint> > { struct { /* ? */ } *x1; struct { /* ? */ } *x2; struct __compressed_pair<ICDrawingOutputPoint *, std::__1::allocator<ICDrawingOutputPoint> > { struct { /* ? */ } *x_3_1_1; } x3; }*)arg2 onQueue:(id)arg3;
- (float)distanceToRulerCenter:(struct CGPoint { float x1; float x2; })arg1;
- (void)drawingAddPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1;
- (void)drawingAddPoints:(struct vector<ICDrawingInputPoint, std::__1::allocator<ICDrawingInputPoint> > { struct { /* ? */ } *x1; struct { /* ? */ } *x2; struct __compressed_pair<ICDrawingInputPoint *, std::__1::allocator<ICDrawingInputPoint> > { struct { /* ? */ } *x_3_1_1; } x3; })arg1 forTouches:(id)arg2;
- (void)drawingBeganWithCommand:(id)arg1 inputType:(int)arg2 start:(id /* block */)arg3;
- (void)drawingCancelledWithCompletion:(id /* block */)arg1;
- (void)drawingEndedWithPreCompletion:(id /* block */)arg1 completion:(id /* block */)arg2;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })eraserOutputPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1 baseValues:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })arg2;
- (void)fixEndHook;
- (void)fixStartHook;
- (struct CGPoint { float x1; float x2; })getRulerSnapLineOriginAndTangent:(struct CGPoint { float x1; float x2; }*)arg1 andNormal:(struct CGPoint { float x1; float x2; }*)arg2;
- (struct vector<ICDrawingOutputPoint, std::__1::allocator<ICDrawingOutputPoint> > { struct { /* ? */ } *x1; struct { /* ? */ } *x2; struct __compressed_pair<ICDrawingOutputPoint *, std::__1::allocator<ICDrawingOutputPoint> > { struct { /* ? */ } *x_3_1_1; } x3; }*)getUpdatedRangeFromIndex:(inout unsigned int*)arg1;
- (void)handleEndCaps;
- (void)handleMarkerStartCapPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; }*)arg1 forInput:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; }*)arg2;
- (id)init;
- (id)initWithDelegate:(id)arg1;
- (id)inputSmoother;
- (BOOL)isSnappedToRuler;
- (BOOL)isSnappedToRulerTopSide;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })markerOutputPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1 baseValues:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })arg2;
- (void)maskToRuler;
- (BOOL)needToCheckForStartHook;
- (id)outputFilter;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })outputPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1 forCommandType:(unsigned int)arg2 baseValues:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })arg3;
- (struct { float x1; float x2; float x3; })parametersforCommandType:(unsigned int)arg1;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })penOutputPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1 baseValues:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })arg2;
- (struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })pencilOutputPoint:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; double x7; BOOL x8; BOOL x9; float x10; })arg1 baseValues:(struct { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; float x2; float x3; float x4; float x5; float x6; })arg2;
- (void)removePredictedTouches;
- (void)reset;
- (float)rulerOffset;
- (struct CGAffineTransform { float x1; float x2; float x3; float x4; float x5; float x6; })rulerTransform;
- (float)rulerWidth;
- (void)setCanSnapToRuler:(BOOL)arg1;
- (void)setInputScale:(float)arg1;
- (void)setInputSmoother:(id)arg1;
- (void)setIsSnappedToRuler:(BOOL)arg1;
- (void)setIsSnappedToRulerTopSide:(BOOL)arg1;
- (void)setNeedToCheckForStartHook:(BOOL)arg1;
- (void)setRulerTransform:(struct CGAffineTransform { float x1; float x2; float x3; float x4; float x5; float x6; })arg1;
- (void)setRulerWidth:(float)arg1;
- (void)setUseRuler:(BOOL)arg1;
- (BOOL)shouldSnapPointToRuler:(struct CGPoint { float x1; float x2; })arg1;
- (void)smoothVelocity;
- (struct CGPoint { float x1; float x2; })snapPointToRuler:(struct CGPoint { float x1; float x2; })arg1;
- (void)snapToRuler;
- (void)snapToRuler:(struct CGAffineTransform { float x1; float x2; float x3; float x4; float x5; float x6; })arg1 width:(float)arg2;
- (void)updateImmutableCount;
- (void)updateOutputPointsFromIndex:(int)arg1;
- (void)updateRulerSnapping;
- (BOOL)useRuler;

@end
